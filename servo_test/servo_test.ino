// https://forum.arduino.cc/index.php?topic=590442
#include <Arduino.h>



// ref: https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/
// forum on Arduino PWM: https://forum.arduino.cc/index.php?topic=354160.0
// Schematic: https://content.arduino.cc/assets/UNO-TH_Rev3e_sch.pdf


// Find min and max compare register values to get 1 ms to 2 ms pulse
// Using 16-bit timer with prescale of 8
// Register value should be number of clock cycles before reset - 1 b/c we count up from 0
int OCR1B_min = 1999; //+1=2000 clock cycles to get 1 ms pulse width (off)
int OCR1B_max = 3999; // to get 2 ms pulse width (max speed)
int max_position = 180;
void setup() {
  
  //Serial setup
  Serial.begin(9600);
  pinMode(A0, INPUT_PULLUP);
  // Set timer output pin data direction
  // From ATMEGA328/P datasheet pgs 13 and 14 and the UNO schematic
  // OC1B -> PB2 -> MCU Pin 16 -> Board Pin 10
  // pg 167: Actual OC1x value will only be visible if data direction for the port pin is set as output (DDR_OC1x)
  //pinMode(10, OUTPUT);
  pinMode(9, OUTPUT);

  // Create variables to store the values to be written to the TIM1 registers
  // Control registers are 8 bits (char)
  char TCCR1A_pre = 0x00; 
  char TCCR1B_pre = 0x00;

  // Set OC1B to non-inverting mode
  // pg 167: INCORRECT INFO: Non-inverted  PWM output can be generated by writing the COM1x[1:0] to 0x3
  // pg 174-175: looks like it is actually 0x2 in register description
  // Below code was tested working
  TCCR1A_pre |= _BV(COM1B1);

  // Set waveform generation mode
  // pg 165: counter is incremented until counter value matches value in OCR1A (WGM1[3:0]=0xF)
  // pg 175: WGM1[3:2] bits found in TCCR1B register, WGM1[1:0] found in TCCR1A register
  TCCR1B_pre |= _BV(WGM13) | _BV(WGM12);
  TCCR1A_pre |= _BV(WGM11) | _BV(WGM10);

  // Select the prescaled clock to use.  See Excel worksheet "PWMCalcs" to see justification.
  TCCR1B_pre |= _BV(CS11);

  // Write control registers
  TCCR1A = TCCR1A_pre;
  TCCR1B = TCCR1B_pre;

  // Write output compare registers (2 bytes)
  // pg 167: f_OCnxPWM = f_CLK_IO / (N*(1+TOP))
  OCR1A = OCR1B_min; // To get 50 Hz frequency
  OCR1B = 3999; // start at 1 ms pulse width

}
int position = -1;
void set_straight()
{
  position = 0;
  while(position <= 180)
  {
    position = position + 1;
    OCR1A = map(position, 0, max_position, OCR1B_min, OCR1B_max);
    delay(20);
  }

  while(position > 90) 
  {
    position = position - 1;
    OCR = map(position, 0, max_position, OCR1B_min, OCR1B_max);
    delay(20);
  }

}
int step = 2;
String data;

int new_position;
void loop() {
  // Read analog input
  set_straight();
  // Voltages are between 0-5V on an UNO per https://www.arduino.cc/reference/en/language/functions/analog-io/analogread/
  if (position == -1)
  {
    set_straight();
  }

  //if (Serial.available() >0)
  //{
    //data = Serial.readStringUntil('\n');
    //new_position = data.toInt();//analogRead(A0);
    //if (new_position > position +step)
    //{
     // position = position - step; 
    //}
    //else if (new_position < position -step)
    //{
     // position = position + step;
    //}
    //else
    //{
      //position = new_position;
      //OCR1B = map(position, 0, max_position, OCR1B_min, OCR1B_max);
     // delay(10);
    //} 
 // }
 

}
