// https://forum.arduino.cc/index.php?topic=590442
#include <Arduino.h>



// ref: https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/
// forum on Arduino PWM: https://forum.arduino.cc/index.php?topic=354160.0
// Schematic: https://content.arduino.cc/assets/UNO-TH_Rev3e_sch.pdf


// Find min and max compare register values to get 1 ms to 2 ms pulse
// Using 16-bit timer with prescale of 8
// Register value should be number of clock cycles before reset - 1 b/c we count up from 0
int OCR1B_min = 1999; //+1=2000 clock cycles to get 1 ms pulse width (off)
int OCR1B_max = 3999; // to get 2 ms pulse width (max speed)

void setup() {
  // Set timer output pin data direction
  // From ATMEGA328/P datasheet pgs 13 and 14 and the UNO schematic
  // OC1B -> PB2 -> MCU Pin 16 -> Board Pin 10
  // pg 167: Actual OC1x value will only be visible if data direction for the port pin is set as output (DDR_OC1x)
  pinMode(10, OUTPUT);

  // Create variables to store the values to be written to the TIM1 registers
  // Control registers are 8 bits (char)
  char TCCR1A_pre = 0x00; 
  char TCCR1B_pre = 0x00;

  // Set OC1B to non-inverting mode
  // pg 167: INCORRECT INFO: Non-inverted  PWM output can be generated by writing the COM1x[1:0] to 0x3
  // pg 174-175: looks like it is actually 0x2 in register description
  // Below code was tested working
  TCCR1A_pre |= _BV(COM1B1);

  // Set waveform generation mode
  // pg 165: counter is incremented until counter value matches value in OCR1A (WGM1[3:0]=0xF)
  // pg 175: WGM1[3:2] bits found in TCCR1B register, WGM1[1:0] found in TCCR1A register
  TCCR1B_pre |= _BV(WGM13) | _BV(WGM12);
  TCCR1A_pre |= _BV(WGM11) | _BV(WGM10);

  // Select the prescaled clock to use.  See Excel worksheet "PWMCalcs" to see justification.
  TCCR1B_pre |= _BV(CS11);

  // Write control registers
  TCCR1A = TCCR1A_pre;
  TCCR1B = TCCR1B_pre;

  // Write output compare registers (2 bytes)
  // pg 167: f_OCnxPWM = f_CLK_IO / (N*(1+TOP))
  OCR1A = 39999; // To get 50 Hz frequency
  OCR1B = OCR1B_min; // start at 1 ms pulse width

}
int potVal = 0;
int inc = 1;
void loop() {
  // Read analog input
  // Voltages are between 0-5V on an UNO per https://www.arduino.cc/reference/en/language/functions/analog-io/analogread/
  potVal = potVal+inc;//analogRead(A0);
  if (potVal > 1023){
      inc = -1;
  }
  if (potVal < 0){
    inc = 1;
  }



  // Map the input to the timer output
  // analogRead() values go from 0 to 1023.  We want to change the register from min to max specified above
  // pg 166: OCR1A is double bufferred, updated when TCNT1 matches TOP
  OCR1B = map(potVal, 0, 1023, OCR1B_min, OCR1B_max);
  
  //analogWrite(10, 17);
  delay(10);

}
//void setup()
//{
//  Serial.begin(9600);
//  Serial.println("poor man's servo sweep");
//
//  //turn off L13
//  pinMode(LED_BUILTIN, OUTPUT);
//  digitalWrite(LED_BUILTIN, LOW);
//
//  pinMode(servoPin, OUTPUT);
//  digitalWrite(servoPin, LOW);
//
//  pinMode(3, OUTPUT);
//  pinMode(11, OUTPUT);
//  TCCR2A = _BV(COM2A0) | _BV(COM2B1) | _BV(WGM20);
//  TCCR2B = _BV(WGM22) | _BV(CS22)| _BV(CS21)| _BV(CS20);           //
//  OCR2A = 156;
//  OCR2B = 4;
//} //setup
//
//void loop()
//{
//
//
//    //unsigned long startTime = millis();
//
//    //// Define the duration of the loop in milliseconds
//    //unsigned long loopDuration = 10000; // 5 seconds
//
//    //while (millis() - startTime < loopDuration){
//        // Move the servo to one side
//        //Serial.println("one side...");
//        //digitalWrite(servoPin, HIGH);
//        //delayMicroseconds(10);    //position
//        //digitalWrite(servoPin, LOW);
//        //delayMicroseconds(18100);   //balance of 20000 cycle
//        //delayMicroseconds(30000-1900);
//    //}
//
//    //startTime = millis();
//
//
//    //while (millis() - startTime < loopDuration){
//        // Move the servo to the other side
//      //  Serial.println("other side");
//        //digitalWrite(servoPin, HIGH);
//        //delayMicroseconds(1100);    //position
//        //digitalWrite(servoPin, LOW);
//        //delayMicroseconds(18900);   //balance of 20000 cycle
//        //delayMicroseconds(30000-1100);
//    //}
//
//} //loop
//
